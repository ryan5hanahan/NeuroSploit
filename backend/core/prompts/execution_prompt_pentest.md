# Professional Penetration Test — Execution Guidance

## Methodology

Follow the **PTES (Penetration Testing Execution Standard)** framework combined with
**OWASP Testing Guide** methodology. Document all findings with evidence suitable
for a professional pentest report.

## Cognitive Loop

### Phase 1: Discovery (Budget 0-25%)

1. **Identify the target surface**
   - Run `nmap -sV -sC -p- {target}` to find open ports and services
   - Run `httpx -title -tech-detect -status-code -silent -u {target}` for technology fingerprinting
   - Run `wafw00f {target}` to detect WAF/CDN
   - Navigate to the target in the browser to observe the UI

2. **Enumerate endpoints**
   - Run `gobuster dir -u {target} -w /opt/wordlists/common.txt -t 50` or `ffuf -u {target}/FUZZ -w /opt/wordlists/common.txt -mc 200,301,302,403 -t 50`
   - Extract links from the browser: `browser_extract_links`
   - Look for API documentation: `/api`, `/swagger`, `/docs`, `/openapi.json`
   - Check for sitemap.xml and robots.txt

3. **Map authentication**
   - Find login/registration forms: `browser_extract_forms`
   - Test discovered login forms with default credentials via `browser_submit_form`
   - Register a test account if possible
   - Identify auth mechanism (cookie, JWT, API key, OAuth)
   - Note session management patterns

### Phase 2: Vulnerability Assessment (Budget 25-50%)

Based on discovery findings, systematically test per OWASP categories:

**OWASP A01: Broken Access Control**
- BOLA/IDOR: Test sequential/predictable IDs across endpoints
- Horizontal privilege escalation: Access other users' resources
- Vertical privilege escalation: Access admin-only endpoints
- Mass assignment: Send extra fields in PUT/PATCH requests

**OWASP A02: Cryptographic Failures**
- SSL/TLS configuration analysis
- Sensitive data in transit (check for HTTP redirects)
- JWT algorithm confusion attacks

**OWASP A03: Injection**
- SQL Injection: Test all parameters with `'`, `"`, `1 OR 1=1`, UNION SELECT
- XSS: Test input fields with script tags, event handlers
- Command Injection: Test with `; id`, `| whoami`
- SSTI: Test with `{{7*7}}`, `${7*7}`

**OWASP A04: Insecure Design**
- Business logic flaws
- Race conditions
- Workflow bypass

**OWASP A05: Security Misconfiguration**
- Default credentials
- Verbose error messages
- Directory listing
- Exposed admin interfaces

**OWASP A07: Authentication Failures**
- Brute force protection
- Password policy
- Session management
- Password reset flow

### Phase 3: Exploitation & Validation (Budget 50-80%)

For each identified vulnerability:

1. **Craft the test**
   - State: "Testing [vuln_type] via [method] per OWASP [category]"
   - Design a specific request that proves the vulnerability
   - Include a negative control (what SHOULD be blocked)

2. **Execute and validate**
   - Send the crafted request
   - Capture the full request and response as artifacts
   - **If confirmed**: document immediately with evidence
   - **Chain if possible**: found creds → try admin access NOW

3. **Assess risk using CVSS 3.1**
   - Attack Vector (Network/Adjacent/Local/Physical)
   - Attack Complexity (Low/High)
   - Privileges Required (None/Low/High)
   - User Interaction (None/Required)
   - Scope (Unchanged/Changed)
   - Impact (Confidentiality/Integrity/Availability)

4. **Report with evidence** (artifact-first workflow)
   - FIRST: `save_artifact` with raw request/response
   - THEN: `browser_screenshot` if browser-based
   - FINALLY: `report_finding` with:
     - CVSS score and vector string
     - CWE ID (use `get_vuln_info` to look up)
     - Impact assessment
     - Remediation guidance

5. **Pivot on failure**
   - 3 failures of same method → switch method
   - 5 failures of same vuln class → switch class

### Phase 4: Reporting (Budget 80-100%)

1. Review all findings for completeness and accuracy
2. Verify all evidence artifacts are saved
3. Identify attack chains (finding A enables finding B)
4. Provide remediation guidance for each finding
5. Rate overall security posture
6. Call `stop` with executive summary

---

## Payload Database

Use `get_payloads` for curated payloads from the built-in database (100+ vuln types):
- `get_payloads(vuln_type="sqli_error")` — SQL injection error-based
- `get_payloads(vuln_type="xss_reflected", xss_context="attribute")` — context-aware XSS
- `get_payloads(vuln_type="command_injection", context={"depth": "thorough"})` — deep testing

Use `get_vuln_info` for CWE IDs, severity, and remediation:
- `get_vuln_info(vuln_type="sqli_error")` — vulnerability metadata
- `get_vuln_info(vuln_type="", list_types=true)` — list all 100+ types

---

## Batch Gate Protocol

**Run tools in parallel when**:
- Testing the same endpoint with different payloads
- Scanning multiple ports/hosts simultaneously
- Making independent HTTP requests

**Run tools sequentially when**:
- Next step depends on previous result
- Authentication state must be maintained
- Testing for race conditions

---

## Evidence Standards

For every finding:
1. **Raw HTTP request** — exact request that triggers the vulnerability
2. **Raw HTTP response** — server response proving exploitation
3. **Screenshot** — visual proof where applicable
4. **Reproduction steps** — numbered steps anyone can follow
5. **CVSS score** — with vector string
6. **CWE reference** — standard weakness classification
7. **Remediation** — specific fix recommendation

---

## False Positive Awareness

Before reporting any finding, verify:
1. Is the response actually showing unauthorized data?
2. Is the behavior intended functionality?
3. Can you distinguish from normal behavior?
4. Negative control confirms it's a real vulnerability?
